{"name":"Tenso","tagline":"Tensō is an elastic REST API gateway for node.js","body":"Tensō\r\n=====\r\n\r\n[![build status](https://secure.travis-ci.org/avoidwork/tenso.svg)](http://travis-ci.org/avoidwork/tenso) [![Gitter](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/avoidwork/tenso?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\r\n\r\nTensō is a REST API gateway for node.js, designed to simplify the implementation of APIs.\r\n\r\nTensō will handle the serialization & creation of hypermedia links, all you have to do is give it `Arrays` or `Objects`.\r\n\r\n## Example\r\nCreating an API with Tensō can be as simple as one statement.\r\n\r\n```javascript\r\nrequire(\"tenso\")({routes: require(__dirname+\"/routes.js\")});\r\n```\r\n\r\n### Creating Routes\r\nRoutes are loaded as a module, with each HTTP method as an export, affording a very customizable API server.\r\n\r\nRoute handlers have the context of the Tensō server, i.e. `this` will allow you to send a response with `this.respond(req, res, body[, status, headers])`. You can also use `res` to `res.respond(body[, status, headers])`, `res.redirect(url)`, or `res.error(status[, Error])`. \r\n\r\nThe following example will create GET routes that will return an empty `Array` at `/`, an `Error` at `/reports/tps`, & a version 4 UUID at `/uuid`.\r\n\r\n```javascript\r\nvar uuid = require(\"tiny-uuid4\");\r\n\r\nmodule.exports.get = {\r\n\t\"/\": [\"reports\", \"uuid\"],\r\n\t\"/reports\": [\"tps\"],\r\n\t\"/reports/tps\": function (req, res) {\r\n\t\tres.error(785, Error(\"TPS Cover Sheet not attached\"));\r\n\t},\r\n\t\"/uuid\": function (req, res) {\r\n\t\tres.send(uuid(), 200, {\"cache-control\": \"no-cache\"});\r\n\t}\r\n};\r\n```\r\n\r\n#### Protected Routes\r\nProtected routes are routes that require authorization for access, and will redirect to authentication end points if needed.\r\n\r\n#### Unprotected Routes\r\nUnprotected routes are routes that do not require authorization for access, and will exit the authorization pipeline early to avoid rate limiting, csrf tokens, & other security measures. These routes are the DMZ of your API! _You_ **must** secure these end points with alternative methods if accepting input!\r\n\r\n### Request Helpers\r\nTensō decorates `req` with \"helpers\" such as `req.ip`, & `req.parsed`. `PATCH`, `PUT`, & `POST` payloads are available as `req.body`. Sessions are available as `req.session` when using `local` authentication.\r\n\r\n## Responses\r\nResponses will have a standard shape, and will be utf-8 by default. The result will be in `data`. Hypermedia (pagination, links, etc.) will be in `links:[ {\"uri\": \"...\", \"rel\": \"...\"}, ...]`, & pagination will also be present via the `Link` HTTP header.\r\n\r\n```json\r\n{\r\n  \"data\": \"`null` or ?\",\r\n  \"error\": \"`null` or an `Error` stack trace / message\",\r\n  \"links\": [],\r\n  \"status\": 200\r\n}\r\n```\r\n\r\n## REST / Hypermedia\r\nHypermedia is a prerequisite of REST, and is best described by the [Richardson Maturity Model](http://martinfowler.com/articles/richardsonMaturityModel.html). Tensō will automagically paginate Arrays of results, or parse Entity representations for keys that imply\r\nrelationships, and create the appropriate Objects in the `link` Array, as well as the `Link` HTTP header. Object keys that match this pattern: `/_(guid|uuid|id|uri|url)$/` will be considered\r\nhypermedia links.\r\n\r\nFor example, if the key `user_id` was found, it would be mapped to `/users/:id` with a link `rel` of `related`.\r\n\r\nTensō will bend the rules of REST when using authentication strategies provided by passport.js, or CSRF if is enabled, because they rely on a session. Session storage is in memory, or Redis. You have the option of a stateless or stateful API.\r\n\r\n## Browsable API / Renderers\r\nTensō 1.4.0 added a few common format renderers, such as CSV, HTML, YAML, & XML. The HTML interface is a browsable API! You can use it to verify requests & responses, or simply poke around your API to see how it behaves.\r\n\r\nCustom renderers can be registered with `server.renderer('name', fn, 'mimetype');`.\r\n\r\n## Cache\r\nTensō has a robust multi-level cache strategy, starting at the response headers. If a response can be cached, an `Etag` will be sent to the `Client`, and registered in an `Etag LRU cache` which Tensō \r\nuses along with a 'cache compressed asset to disk' strategy, allowing Tensō to stream the last known version of a resource to the next `Client` that supports the same compression (gzip or deflate).\r\n`Etags` will lazy expire from the cache, to minimize wasted cycles.\r\n\r\nCaching can be disabled by setting the `cache-control` header to a \"private\" or \"no cache\" directive (see the above `/uuid` example).\r\n \r\n## Configuration\r\nThis is a sample configuration for Tensō, without authentication or SSL. This would be ideal for development, but not production! Enabling SSL is as easy as providing file paths for the two keys.\r\n\r\n```\r\n{\r\n\t\"auth\": {}, /* Optional, see Authentication section */\r\n\t\"cacheSize\": 1000, /* Optional, size of Etag LRU cache */\r\n\t\"compress\": false, /* Optional, enabled by default */\r\n\t\"headers\": {}, /* Optional, custom headers */\r\n\t\"hostname\": \"localhost\", /* Optional, default is 'localhost' */\r\n\t\"json\": 2, /* Optional, default indent for 'pretty' JSON */\r\n\t\"logging\": {\r\n\t\t\"level\": \"info\", /* Optional */\r\n\t\t\"enabled\": true, /* Optional */\r\n\t\t\"stack\": true /* Optional */\r\n\t},\r\n\t\"port\": 8000, /* Optional */\r\n\t\"routes\": require(\"./routes.js\"), /* Required! */\r\n\t\"session\": { /* Optional */\r\n\t\t\"secret\": null,\r\n\t\t\"store\": \"memory\", /* \"memory\" or \"redis\" */\r\n\t\t\"redis\": {} /* See connect-redis for options */\r\n\t},\r\n\t\"ssl\": { /* Optional */\r\n\t\t\"cert\": null,\r\n\t\t\"key\": null\r\n\t},\r\n\t\"title\": \"My API\", /* Page title for browsable API */\r\n\t\"uid\": 33 /* Optional, system account uid to drop to after starting with elevated privileges to run on a low port */\r\n}\r\n```\r\n\r\n## Authentication\r\nThe `protect` Array is the endpoints that will require authentication. The `redirect` String is the end point users will be redirected to upon successfully authenticating, the default is `/`.\r\n\r\nSessions are used for non `Basic` or `Bearer Token` authentication, and will have `/login`, `/logout`, & custom routes. Redis is supported for session storage.\r\n\r\nMultiple authentication strategies can be enabled at once.\r\n\r\n### Basic Auth\r\n```\r\n{\r\n\t\"auth\": {\r\n\t\t\"basic\": {\r\n\t\t\t\"enabled\": true,\r\n\t\t\t\"list\": [\"username:password\", ...],\r\n\t\t},\r\n\t\t\"protect\": [\"/\"]\r\n\t}\r\n}\r\n```\r\n\r\n### Facebook\r\nFacebook authentication will create `/auth`, `/auth/facebook`, & `/auth/facebook/callback` routes. `auth(accessToken, refreshToken, profile, callback)` must execute `callback(err, user)`.\r\n \r\n```\r\n{\r\n\t\"auth\": {\r\n\t\t\"facebook\": {\r\n\t\t\t\"enabled\": true,\r\n\t\t\t\"auth\": function ( ... ) { ... }, /* Authentication handler, to 'find' or 'create' a User */\r\n\t\t\t\"client_id\": \"\", /* Get this from Facebook */\r\n\t\t\t\"client_secret\": \"\" /* Get this from Facebook */\r\n\t\t},\r\n\t\t\"protect\": [\"/private\"]\r\n\t}\r\n}\r\n```\r\n\r\n### Google\r\nGoogle authentication (OpenID) will create `/auth`, `/auth/google`, & `/auth/google/callback` routes. `auth(identifier, profile, callback)` must execute `callback(err, user)`.\r\n \r\n```\r\n{\r\n\t\"auth\": {\r\n\t\t\"google\": {\r\n\t\t\t\"enabled\": true,\r\n\t\t\t\"auth\": function ( ... ) { ... }, /* Authentication handler, to 'find' or 'create' a User */\r\n\t\t},\r\n\t\t\"protect\": [\"/private\"]\r\n\t}\r\n}\r\n```\r\n\r\n### LinkedIn\r\nLinkedIn authentication will create `/auth`, `/auth/linkedin`, & `/auth/linkedin/callback` routes. `auth(token, tokenSecret, profile, callback)` must execute `callback(err, user)`.\r\n \r\n```\r\n{\r\n\t\"auth\": {\r\n\t\t\"linkedin\": {\r\n\t\t\t\"enabled\": true,\r\n\t\t\t\"auth\": function ( ... ) { ... }, /* Authentication handler, to 'find' or 'create' a User */\r\n\t\t\t\"client_id\": \"\", /* Get this from LinkedIn */\r\n\t\t\t\"client_secret\": \"\", /* Get this from LinkedIn */,\r\n\t\t\t\"scope\": \"\" /* Optional, permission scope */\r\n\t\t}\r\n\t\t\"protect\": [\"/private\"]\r\n\t}\r\n}\r\n```\r\n\r\n### Local\r\nLocal authentication will create `/login`. `auth(username, password)` must execute `callback(err, user)`.\r\n\r\n```\r\n{\r\n\t\"auth\": {\r\n\t\t\"local\": {\r\n\t\t\t\"enabled\": true,\r\n\t\t\t\"auth\": function ( ... ) { ... }, /* Authentication handler, to 'find' or 'create' a User */\r\n\t\t}\r\n\t\t\"protect\": [\"/private\"]\r\n\t}\r\n}\r\n```\r\n\r\n### OAuth2\r\nOAuth2 authentication will create `/auth`, `/auth/oauth2`, & `/auth/oauth2/callback` routes. `auth(accessToken, refreshToken, profile, callback)` must execute `callback(err, user)`.\r\n \r\n```\r\n{\r\n\t\"auth\": {\r\n\t\t\"oauth2\": {\r\n\t\t\t\"enabled\": true,\r\n\t\t\t\"auth\": function ( ... ) { ... }, /* Authentication handler, to 'find' or 'create' a User */\r\n\t\t\t\"auth_url\": \"\", /* Authorization URL */\r\n\t\t\t\"token_url\": \"\", /* Token URL */\r\n\t\t\t\"client_id\": \"\", /* Get this from authorization server */\r\n\t\t\t\"client_secret\": \"\" /* Get this from authorization server */\r\n\t\t},\r\n\t\t\"protect\": [\"/private\"]\r\n\t}\r\n}\r\n```\r\n\r\n### Oauth2 Bearer Token\r\n```\r\n{\r\n\t\"auth\": {\r\n\t\t\"bearer\": {\r\n\t\t\t\"enabled\": true,\r\n\t\t\t\"tokens\": [\"abc\", ...]\r\n\t\t},\r\n\t\t\"protect\": [\"/\"]\r\n\t}\r\n}\r\n```\r\n\r\n### SAML\r\nSAML authentication will create `/auth`, `/auth/saml`, & `/auth/saml/callback` routes. `auth(profile, callback)` must execute `callback(err, user)`.\r\n\r\nTensō uses [passport-saml](https://github.com/bergie/passport-saml), for configuration options please visit it's homepage.\r\n \r\n```\r\n{\r\n\t\"auth\": {\r\n\t\t\"saml\": {\r\n\t\t\t\"enabled\": true,\r\n\t\t\t...\r\n\t\t},\r\n\t\t\"protect\": [\"/private\"]\r\n\t}\r\n}\r\n```\r\n\r\n### Twitter\r\nTwitter authentication will create `/auth`, `/auth/twitter`, & `/auth/twitter/callback` routes. `auth(token, tokenSecret, profile, callback)` must execute `callback(err, user)`.\r\n \r\n```\r\n{\r\n\t\"auth\": {\r\n\t\t\"twitter\": {\r\n\t\t\t\"enabled\": true,\r\n\t\t\t\"auth\": function ( ... ) { ... }, /* Authentication handler, to 'find' or 'create' a User */\r\n\t\t\t\"consumer_key\": \"\", /* Get this from Twitter */\r\n\t\t\t\"consumer_secret\": \"\" /* Get this from Twitter */\r\n\t\t},\r\n\t\t\"protect\": [\"/private\"]\r\n\t}\r\n}\r\n```\r\n\r\n## Sessions\r\nSessions can use a memory (default) or redis store. Memory will limit your sessions to a single server instance, while redis will allow you to share sessions across a cluster of processes, or machines. To use redis, set the `store` property to \"redis\".\r\n\r\nIf the session `secret` is not provided, a version 4 `UUID` will be used.\r\n\r\n```\r\n{\r\n\t\"session\" : {\r\n\t\t\"secret\": \"my secret\",\r\n\t\t\"store\": \"redis\",\r\n\t\t\"redis\": {\r\n\t\t\t\"host\": \"127.0.0.1\",\r\n\t\t\t\"port\": 6379\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\n\r\n## Security\r\nTensō uses [lusca](https://github.com/krakenjs/lusca#api) for security as a middleware. Please see it's documentation for how to configure it; each method & argument is a key:value pair for `security`.\r\n\r\n```\r\n{\r\n\t\"security\": { ... }\r\n}\r\n```\r\n\r\n## Compression\r\nCompression is enabled by default, for Clients that support `gzip` or `deflate`. Compression will be disabled if `SSL` is enabled.\r\n\r\n## Rate Limiting\r\nRate limiting is controlled by configuration, and is disabled by default. Rate limiting is based on `token`, `session`, or `ip`, depending upon authentication method.\r\n\r\nRate limiting can be overridden by providing an `override` function that takes `req` & `rate`, and must return (a modified) `rate`.\r\n\r\n```\r\n{\r\n\t\"rate\": {\r\n\t\t\"enabled\": true,\r\n\t\t\"limit\": 450, /* Maximum requests allowed before `reset` */\r\n\t\t\"reset\": 900, /* TTL in seconds */\r\n\t\t\"status\": 429, /* Optional HTTP status */\r\n\t\t\"message\": \"Too many requests\",  /* Optional error message */\r\n\t\t\"override\": function ( req, rate ) { ... } /* Override the default rate limiting */\r\n\t}\r\n}\r\n```\r\n\r\n## Limiting upload size\r\nA 'max byte' limit can be enforced on all routes that handle `PATCH`, `POST`, & `PUT` requests. The default limit is 1 MB (1048576 b).\r\n\r\n```\r\n{\r\n\t\"maxBytes\": 5242880\r\n}\r\n```\r\n\r\n## Logging\r\nStandard log levels are supported, and are emitted to `stdout` & `stderr`. Stack traces can be enabled.\r\n\r\n```\r\n{\r\n    \"logging\": {\r\n        \"level\": \"warn\",\r\n        \"enabled\": true,\r\n        \"stack\": true\r\n    }\r\n}\r\n```\r\n\r\n## WebSocket\r\nA companion WebSocket server can be enabled by configuration, with event handlers (`connection`, `message`, & `close`) set as a `socket` route.\r\n\r\nParameters for `message` are `socket, message, binary, server, tenso`, and `socket, server, tenso` for `connection` & `close`.\r\n\r\nServer options can be found [here](https://github.com/alexhultman/node-lws#new-lwsserveroptions)\r\n\r\n```\r\n{\r\n    \"websocket\": {\r\n        \"enabled\": true,\r\n        \"options\": {\r\n            \"port\": 3000\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## License\r\nCopyright (c) 2016 Jason Mulligan  \r\nLicensed under the BSD-3 license.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}